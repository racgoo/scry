import Output from "@utils/output";
import Format from "@tracer/format";
import { TRACE_EVENT_NAME } from "@babel/scry.constant";
import Transformer from "@utils/transformer";
import Environment from "@utils/enviroment";

//Tracer class. for single instance.
class Tracer {
  private isTracing = false;
  //Trace details(like stack trace)
  private details: Detail[] = [];
  private timestamp: number = 0;
  //Trace duration(not used)
  private duration: number = 0;
  //Bind onTrace function(for static method call)
  private boundOnTrace = this.onTrace.bind(this) as EventListener;

  //Start tracing
  public start() {
    if (this.isTracing) {
      Output.printError(
        "Tracing is already started. Please call Tracer.end() first."
      );
      return;
    }
    this.isTracing = true;
    //Init start time
    const now = Date.now();
    this.timestamp = now;
    //Register event listener according to the execution environment
    if (Environment.isNodeJS()) {
      //Nodejs use process event
      process.on(TRACE_EVENT_NAME, this.boundOnTrace);
    } else {
      //Browser use globalThis event
      globalThis.addEventListener(TRACE_EVENT_NAME, this.boundOnTrace);
    }
    Output.printDivider();
    Output.print("Tracer is started");
  }

  //end tracing
  end() {
    if (!this.isTracing) {
      Output.printError(
        "Tracing is not started. Please call Tracer.start() first."
      );
      return;
    }
    this.isTracing = false;
    //Remove event listener according to the execution environment
    if (Environment.isNodeJS()) {
      //Nodejs use process event
      process.removeListener(TRACE_EVENT_NAME, this.boundOnTrace);
    } else {
      //Browser use globalThis event
      globalThis.removeEventListener(TRACE_EVENT_NAME, this.boundOnTrace);
    }
    //Update duration
    this.duration = Date.now() - this.timestamp;
    Output.print("Tracing is ended");
    //Make trace tree(hierarchical tree structure by call)
    const traceNodes = this.makeTraceNodes(this.details);
    //Make display result(for formatting)
    const displayResult = this.makeDisplayResult(traceNodes);
    //Save result in file
    if (Environment.isNodeJS()) {
      const htmlRoot = Format.generateHtmlRoot(displayResult);
      import("fs").then((fs) => {
        if (!fs.existsSync("scry")) {
          fs.mkdirSync("scry");
        }
        fs.writeFileSync("scry/curernt-trace.html", htmlRoot);
      });
    }

    //Display result in browser
    if (!Environment.isNodeJS()) {
      for (let i = 0; i < displayResult.length; i++) {
        //hide detail link
        console.groupCollapsed(displayResult[i].title);
        console.log(displayResult[i].url);
        console.groupEnd();
      }
    }

    //Clear settings
    this.resetSettings();
  }

  //OnTrace function. called when trace event is emitted.
  private onTrace(event: unknown) {
    // Nodejs use event directly, browser use custom event with detail
    const detail = Environment.isNodeJS()
      ? event
      : (event as CustomEvent).detail;
    //Save as detail(for making tree)
    this.details.push(detail);
    //If detail is error, show raw error(not trace tree)
    if (detail.returnValue instanceof Error) {
      Output.printError(detail.returnValue);
    }
  }

  private makeTraceNodes(details: Detail[]): TraceNode[] {
    //Root TraceNodes (root can be multiple)
    //ex) Trace.start() foo() bar()  Trace.end()
    // traceNodes = [ foo-node, bar-node]
    const traceNodes: TraceNode[] = [];
    //Map for TraceNode(indexed by traceId)
    const nodeMap = new Map<string, TraceNode>();
    //Stack for parent-child relationship
    const callStack: string[] = [];

    //Create node and add children
    for (let i = 0; i < details.length; i++) {
      //Current detail
      const detail = details[i];
      //If "enter" event, create new node and add children
      if (detail.type === "enter") {
        //Create new node
        const node: TraceNode = {
          traceId: detail.traceId,
          name: detail.name,
          source: detail.source,
          args: detail.args || [],
          children: [],
          completed: false,
          chained: detail.chained,
          parentTraceId: detail.parentTraceId,
        };
        //Save to map
        nodeMap.set(detail.traceId, node);
        //Save to callstack(for parent-child relationship)
        callStack.push(detail.traceId);

        //under code is generated by claude.. so i have to fix it
        //it's not good code. but i will  fix it

        // 부모-자식 관계 설정
        if (callStack.length > 1) {
          const parentId = callStack[callStack.length - 2];
          const parent = nodeMap.get(parentId);

          if (parent && !parent.completed) {
            parent.children.push(node);
          } else {
            // 부모가 이미 완료된 경우 루트로 처리
            traceNodes.push(node);
          }
        } else {
          // 루트 레벨 노드
          traceNodes.push(node);
        }
      } else if (detail.type === "exit") {
        // traceId로 노드 찾기
        const node = nodeMap.get(detail.traceId);

        if (node) {
          // exit 이벤트 정보 추가
          node.returnValue = detail.returnValue;
          node.completed = true;

          // 콜스택에서 제거 (가장 최근에 추가된 같은 traceId 항목)
          const stackIndex = callStack.lastIndexOf(detail.traceId);
          if (stackIndex !== -1) {
            callStack.splice(stackIndex, 1);
          }
        }
      }
    }

    //Remove "end" event trace(it's not trace tree. include when Trace.end() is called)
    traceNodes.pop();
    return traceNodes;
  }

  //Make display result(for console)
  private makeDisplayResult(
    traceNodes: TraceNode[],
    depth = 0
  ): DisplayResult[] {
    const result: DisplayResult[] = [];
    //Iterate traceNodes(they are root nodes)
    for (const node of traceNodes) {
      //Indent and prefix for display
      const indent = "ㅤㅤ".repeat(depth);
      const prefix = depth > 0 ? "└─ " : "";
      //Generate html content
      const htmlContent = Format.generateHtmlContent(node);
      //Generate data url
      const dataUrl = `data:text/html;base64,${Transformer.toBase64(
        htmlContent
      )}`;
      //Generate args string
      const args = node.args.map((arg) => JSON.stringify(arg)).join(", ");
      //Save to result
      result.push({
        title: `${indent}${prefix}${node.name}(${args})`,
        url: dataUrl,
      });
      //Recursive call for children
      if (node.children?.length > 0) {
        result.push(...this.makeDisplayResult(node.children, depth + 1));
      }
    }
    return result;
  }

  //Reset settings(Trace is single instance but, v8(nodejs,browser) use signle thread, there is no side effect)
  private resetSettings() {
    this.isTracing = false;
    this.details = [];
    this.timestamp = 0;
    this.duration = 0;
  }
}

export default Tracer;
